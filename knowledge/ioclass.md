I/O 的分类
---------------

   1，阻塞I/O
   解释：
   相当于到一个饭店点菜，服务员拿着菜单到厨房交给厨师，然后就在出菜口等着，直到厨师做完后交给服务员；其中服务员在出菜口等待的过程就叫阻塞IO；
   运行原理：
   应用程序调用一个IO函数，导致应用程序阻塞，（例如浏览器请求时上面一直转圈）等待数据准备好，如果数据没有准备好，就一直等待，直至准备好，从内核拷贝到用户空间，IO函数返回成功指示

   2，非阻塞I/O
   解释：
   相当于服务员把菜单交给厨师后就去干别的了，一定时间内就去查看是否准备好了，如果准备好了就调用系统copy资源信息到自己的缓冲区内
   运行原理：
   我们先把套接字设置为非阻塞告诉内核，当所有请求的IO操作无法完成时，不要将程序睡眠，而是返回一个错误，这样我们的IO操作函数将不断的测试数据是否准备好，如果没有准备好，继续测试，直至准备好位置，在这个不断测试的过程中，会大量暂用CPU的时间。一般web服务器都不适用这种IO模型

   3，复用I/O
   解释：
   相当于多个服务员把菜单交给多个厨师后，开始等待，等待的对象是一个机器，当厨师做完后，按下机器，机器告诉服务员，好了，可以上菜了，跟阻塞IO的区别是中间多了一个机器，这个机器可以同时让多个服务员等待
   运行原理：
   IO复用模型会用到select、poll跟epoll函数，这两个函数也会使进程阻塞，不同的是这几个函数可以同时阻塞多个IO操作。而且同时第多个读操作，多个写操作进行检测。直到有数据可读或可写的时候才真正调用IO操作函数

   4，信号I/O
   解释：
   相当于服务员把菜单交给厨师后，就去干别的了，厨师这边做好后叫服务员传菜
   运行原理：
   我们允许套接口进行信号渠道IO，并安装一个信号处理函数，进程继续运行，并不阻塞，当数据准备好了，会响应给进程一个SIGIO信息，可以在信号处理函数中调用IO操作函数处理数据

   5，异步I/O
   解释：
   相当于服务员把菜单交给厨师后，告诉厨师，你做好了交给XXX服务员就行，就去干别的了，厨师做好后就交给XXX服务员
   运行原理：
   当一个异步过程调用发出后，调用者不用立即得到结果，时间处理这个调用的部分在完成后，通过状态，通知和回调来通知调用者的输入输出操作
   （例如:ajax的异步，总是有一个函数接收成功或失败的数据，其他参数发送后就不管了）
   其中同步IO为：
   阻塞IO，非阻塞IO,复用IO
      异步IO为：
   信号IO（半异步），异步IO

   “阻塞”与"非阻塞"与"同步"与“异步"不能简单的从字面理解，提供一个从分布式系统角度的回答。
   -------------------------------------------------------------------------------
   
   1.同步与异步
   同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication)
   所谓同步，就是在发出一个*调用*时，在没有得到结果之前，该*调用*就不返回。但是一旦调用返回，就得到返回值了。
   换句话说，就是由*调用者*主动等待这个*调用*的结果。

   而异步则是相反，*调用*在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在*调用*发出后，*被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。

   典型的异步编程模型比如Node.js

   举个通俗的例子：
   你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下"，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。
   而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。

   2. 阻塞与非阻塞
   阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.

   阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
   非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

   还是上面的例子，
   你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。
   在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。

   同步和异步针对应用程序来，关注的是程序中间的协作关系；阻塞与非阻塞更关注的是单个进程的执行状态。

   同步：执行一个操作之后，等待结果，然后才继续执行后续的操作。

   异步：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没执行完的操作。

   阻塞：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作。

   非阻塞：进程给CPU传达任我后，继续处理后续的操作，隔断时间再来询问之前的操作是否完成。这样的过程其实也叫轮询。
